{"version":3,"sources":["../Runware/reconnect.ts","../Runware/types.ts","../Runware/utils.ts","../Runware/async-retry.ts","../Runware/Runware-base.ts","../Runware/Runware-client.ts","../Runware/Runware-server.ts","../Runware/Runware.ts"],"sourcesContent":["// @ts-nocheck\n/*\nReady state constants\nhttps://developer.mozilla.org/en-US/docs/Web/API/WebSocket#Ready_state_constants\n\nCONNECTING 0 The connection is not yet open.\nOPEN       1 The connection is open and ready to communicate.\nCLOSING    2 The connection is in the process of closing.\nCLOSED     3 The connection is closed or couldn't be opened.\n*/\ntype Options = {\n  constructor?: new (url: string, protocols?: string | string[]) => WebSocket;\n  maxReconnectionDelay?: number;\n  minReconnectionDelay?: number;\n  reconnectionDelayGrowFactor?: number;\n  connectionTimeout?: number;\n  maxRetries?: number;\n  debug?: boolean;\n};\n\nconst isWebSocket = (constructor) => constructor && constructor.CLOSING === 2;\n\nconst isGlobalWebSocket = () =>\n  typeof WebSocket !== \"undefined\" && isWebSocket(WebSocket);\n\nconst getDefaultOptions = () =>\n  <Options>{\n    constructor: isGlobalWebSocket() ? WebSocket : null,\n    maxReconnectionDelay: 10000,\n    minReconnectionDelay: 1500,\n    reconnectionDelayGrowFactor: 1.3,\n    connectionTimeout: 4000,\n    maxRetries: Infinity,\n    debug: false,\n  };\n\nconst bypassProperty = (src, dst, name: string) => {\n  Object.defineProperty(dst, name, {\n    get: () => src[name],\n    set: (value) => {\n      src[name] = value;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n};\n\nconst initReconnectionDelay = (config: Options) =>\n  config.minReconnectionDelay + Math.random() * config.minReconnectionDelay;\n\nconst updateReconnectionDelay = (config: Options, previousDelay: number) => {\n  const newDelay = previousDelay * config.reconnectionDelayGrowFactor;\n  return newDelay > config.maxReconnectionDelay\n    ? config.maxReconnectionDelay\n    : newDelay;\n};\n\nconst LEVEL_0_EVENTS = [\"onopen\", \"onclose\", \"onmessage\", \"onerror\"];\n\nconst reassignEventListeners = (ws: WebSocket, oldWs, listeners) => {\n  Object.keys(listeners).forEach((type) => {\n    listeners[type].forEach(([listener, options]) => {\n      ws.addEventListener(type, listener, options);\n    });\n  });\n  if (oldWs) {\n    LEVEL_0_EVENTS.forEach((name) => {\n      ws[name] = oldWs[name];\n    });\n  }\n};\n\nconst ReconnectingWebsocket = function (\n  url: string,\n  protocols?: string | string[],\n  options = <Options>{}\n) {\n  let ws: WebSocket;\n  let connectingTimeout;\n  let reconnectDelay = 0;\n  let retriesCount = 0;\n  let shouldRetry = true;\n  const listeners: any = {};\n\n  // require new to construct\n  if (!(this instanceof ReconnectingWebsocket)) {\n    throw new TypeError(\n      \"Failed to construct 'ReconnectingWebSocket': Please use the 'new' operator\"\n    );\n  }\n\n  // Set config. Not using `Object.assign` because of IE11\n  const config = getDefaultOptions();\n  Object.keys(config)\n    .filter((key) => options.hasOwnProperty(key))\n    .forEach((key) => (config[key] = options[key]));\n\n  if (!isWebSocket(config.constructor)) {\n    throw new TypeError(\n      \"Invalid WebSocket constructor. Set `options.constructor`\"\n    );\n  }\n\n  const log = config.debug\n    ? (...params) => console.log(\"RWS:\", ...params)\n    : () => {};\n\n  /**\n   * Not using dispatchEvent, otherwise we must use a DOM Event object\n   * Deferred because we want to handle the close event before this\n   */\n  const emitError = (code: string, msg: string) =>\n    setTimeout(() => {\n      const err = <any>new Error(msg);\n      err.code = code;\n      if (Array.isArray(listeners.error)) {\n        listeners.error.forEach(([fn]) => fn(err));\n      }\n      if (ws.onerror) {\n        ws.onerror(err);\n      }\n    }, 0);\n\n  const handleClose = () => {\n    log(\"close\");\n    retriesCount++;\n    log(\"retries count:\", retriesCount);\n    if (retriesCount > config.maxRetries) {\n      emitError(\"EHOSTDOWN\", \"Too many failed connection attempts\");\n      return;\n    }\n    if (!reconnectDelay) {\n      reconnectDelay = initReconnectionDelay(config);\n    } else {\n      reconnectDelay = updateReconnectionDelay(config, reconnectDelay);\n    }\n    log(\"reconnectDelay:\", reconnectDelay);\n\n    if (shouldRetry) {\n      setTimeout(connect, reconnectDelay);\n    }\n  };\n\n  const connect = () => {\n    log(\"connect\");\n    const oldWs = ws;\n    ws = new (<any>config.constructor)(url, protocols);\n\n    connectingTimeout = setTimeout(() => {\n      log(\"timeout\");\n      ws.close();\n      emitError(\"ETIMEDOUT\", \"Connection timeout\");\n    }, config.connectionTimeout);\n\n    log(\"bypass properties\");\n    for (let key in ws) {\n      // @todo move to constant\n      if (\n        [\"addEventListener\", \"removeEventListener\", \"close\", \"send\"].indexOf(\n          key\n        ) < 0\n      ) {\n        bypassProperty(ws, this, key);\n      }\n    }\n\n    ws.addEventListener(\"open\", () => {\n      clearTimeout(connectingTimeout);\n      log(\"open\");\n      reconnectDelay = initReconnectionDelay(config);\n      log(\"reconnectDelay:\", reconnectDelay);\n      retriesCount = 0;\n    });\n\n    ws.addEventListener(\"close\", handleClose);\n\n    reassignEventListeners(ws, oldWs, listeners);\n  };\n\n  log(\"init\");\n  connect();\n\n  this.close = (\n    code = 1000,\n    reason = \"\",\n    { keepClosed = false, fastClose = true, delay = 0 } = {}\n  ) => {\n    if (delay) {\n      reconnectDelay = delay;\n    }\n    shouldRetry = !keepClosed;\n\n    ws.close(code, reason);\n\n    if (fastClose) {\n      const fakeCloseEvent = <CloseEvent>{\n        code,\n        reason,\n        wasClean: true,\n      };\n\n      // execute close listeners soon with a fake closeEvent\n      // and remove all close listeners from the WS instance\n      // so they don't get fired on the real close.\n\n      handleClose();\n\n      if (Array.isArray(listeners.close)) {\n        listeners.close.forEach(([listener, options]) => {\n          listener(fakeCloseEvent);\n          ws.removeEventListener(\"close\", listener, options);\n        });\n      }\n\n      if (ws.onclose) {\n        ws.onclose(fakeCloseEvent);\n        ws.onclose = null;\n      }\n    }\n  };\n\n  this.send = (data) => {\n    ws.send(data);\n  };\n\n  this.addEventListener = (\n    type: string,\n    listener: EventListener,\n    options: any\n  ) => {\n    if (Array.isArray(listeners[type])) {\n      if (!listeners[type].some(([l]) => l === listener)) {\n        listeners[type].push([listener, options]);\n      }\n    } else {\n      listeners[type] = [[listener, options]];\n    }\n    ws.addEventListener(type, listener, options);\n  };\n\n  this.removeEventListener = (\n    type: string,\n    listener: EventListener,\n    options: any\n  ) => {\n    if (Array.isArray(listeners[type])) {\n      listeners[type] = listeners[type].filter(([l]) => l !== listener);\n    }\n    ws.removeEventListener(type, listener, options);\n  };\n};\n\nexport = ReconnectingWebsocket;\n","export enum Environment {\n  PRODUCTION = \"PRODUCTION\",\n  DEVELOPMENT = \"DEVELOPMENT\",\n  TEST = \"TEST\",\n}\nexport enum SdkType {\n  CLIENT = \"CLIENT\",\n  SERVER = \"SERVER\",\n}\n\nexport enum ETaskType {\n  IMAGE_INFERENCE = \"imageInference\",\n  IMAGE_UPLOAD = \"imageUpload\",\n  IMAGE_UPSCALE = \"imageUpscale\",\n  IMAGE_BACKGROUND_REMOVAL = \"imageBackgroundRemoval\",\n  VIDEO_INFERENCE = \"videoInference\",\n  GET_RESPONSE = \"getResponse\",\n  PHOTO_MAKER = \"photoMaker\",\n  IMAGE_CAPTION = \"imageCaption\",\n  IMAGE_CONTROL_NET_PRE_PROCESS = \"imageControlNetPreProcess\",\n  IMAGE_MASKING = \"imageMasking\",\n  PROMPT_ENHANCE = \"promptEnhance\",\n  AUTHENTICATION = \"authentication\",\n  MODEL_UPLOAD = \"modelUpload\",\n  MODEL_SEARCH = \"modelSearch\",\n}\n\nexport type RunwareBaseType = {\n  apiKey: string;\n  url?: string;\n  shouldReconnect?: boolean;\n  globalMaxRetries?: number;\n  timeoutDuration?: number;\n};\n\nexport type IOutputType = \"base64Data\" | \"dataURI\" | \"URL\";\nexport type IOutputFormat = \"JPG\" | \"PNG\" | \"WEBP\";\n\nexport interface IAdditionalResponsePayload {\n  includePayload?: boolean;\n  includeGenerationTime?: boolean;\n}\n\nexport interface IImage {\n  taskType: ETaskType;\n  imageUUID: string;\n  inputImageUUID?: string;\n  taskUUID: string;\n  imageURL?: string;\n  imageBase64Data?: string;\n  imageDataURI?: string;\n  NSFWContent?: boolean;\n  cost?: number;\n  seed: number;\n}\n\nexport interface ITextToImage extends IImage {\n  positivePrompt?: string;\n  negativePrompt?: string;\n}\n\nexport interface IVideoToImage {\n  taskUUID: string;\n  taskType: string;\n  status: string;\n  videoUUID?: string;\n  cost?: number;\n  seed?: number;\n  videoURL?: string;\n}\nexport interface IControlNetImage {\n  taskUUID: string;\n  inputImageUUID: string;\n  guideImageUUID: string;\n  guideImageURL?: string;\n  guideImageBase64Data?: string;\n  guideImageDataURI?: string;\n  cost?: number;\n}\n\ninterface ILora {\n  model: string | number;\n  weight: number;\n}\n\nexport enum EControlMode {\n  BALANCED = \"balanced\",\n  PROMPT = \"prompt\",\n  CONTROL_NET = \"controlnet\",\n}\n\nexport type IControlNetGeneral = {\n  model: string;\n  guideImage: string | File;\n  weight?: number;\n  startStep?: number;\n  startStepPercentage?: number;\n  endStep?: number;\n  endStepPercentage?: number;\n  controlMode: EControlMode;\n};\nexport type IControlNetPreprocess = {\n  inputImage: string | File;\n  preProcessorType: EPreProcessorGroup;\n  height?: number;\n  width?: number;\n  outputType?: IOutputType;\n  outputFormat?: IOutputFormat;\n  highThresholdCanny?: number;\n  lowThresholdCanny?: number;\n  includeHandsAndFaceOpenPose?: boolean;\n  includeCost?: boolean;\n  outputQuality?: number;\n\n  customTaskUUID?: string;\n  retry?: number;\n} & IAdditionalResponsePayload;\n\n// export type IControlNetA = RequireOnlyOne<\n//   IControlNetGeneral,\n//   \"guideImage\" | \"guideImageUnprocessed\"\n// >;\n\n// export type IControlNetCanny = IControlNetA & {\n//   preprocessor: \"canny\";\n//   lowThresholdCanny: Number;\n//   highThresholdCanny: Number;\n//   outputType?: IOutputType;\n// };\n\n// export type IControlNetHandsAndFace = IControlNetA & {\n//   preprocessor: keyof typeof EOpenPosePreProcessor;\n//   includeHandsAndFaceOpenPose: boolean;\n//   outputType?: IOutputType;\n// };\n\nexport type IControlNet = IControlNetGeneral;\n\nexport type IControlNetWithUUID = Omit<IControlNet, \"guideImage\"> & {\n  guideImage?: string;\n};\n\nexport interface IError {\n  error: boolean;\n  errorMessage: string;\n  taskUUID: string;\n}\n\nexport type TPromptWeighting = \"compel\" | \"sdEmbeds\";\n\nexport interface IRequestImage extends IAdditionalResponsePayload {\n  outputType?: IOutputType;\n  outputFormat?: IOutputFormat;\n  uploadEndpoint?: string;\n  checkNSFW?: boolean;\n  positivePrompt: string;\n  negativePrompt?: string;\n  seedImage?: File | string;\n  maskImage?: File | string;\n  strength?: number;\n  height?: number;\n  width?: number;\n  model: number | string;\n  steps?: number;\n  scheduler?: string;\n  seed?: number;\n  maskMargin?: number;\n  CFGScale?: number;\n  clipSkip?: number;\n  /**\n   * @deprecated The usePromptWeighting should not be used, use promptWeighting instead\n   */\n  usePromptWeighting?: boolean;\n  promptWeighting?: TPromptWeighting;\n  numberResults?: number; // default to 1\n  includeCost?: boolean;\n  outputQuality?: number;\n\n  controlNet?: IControlNet[];\n  lora?: ILora[];\n  embeddings?: IEmbedding[];\n  ipAdapters?: IipAdapter[];\n  outpaint?: IOutpaint;\n  refiner?: IRefiner;\n  acceleratorOptions?: TAcceleratorOptions;\n  advancedFeatures?: {\n    layerDiffuse: boolean;\n  };\n  referenceImages?: string[];\n\n  // imageSize?: number;\n  customTaskUUID?: string;\n  onPartialImages?: (images: IImage[], error?: IError) => void;\n  retry?: number;\n  // gScale?: number;\n}\n\nexport type TAcceleratorOptions =\n  | { teaCache: boolean; teaCacheDistance: number }\n  | {\n      deepCache: boolean;\n      deepCacheInterval: number;\n      deepCacheBranchId: number;\n    };\n\nexport interface IOutpaint {\n  top?: number;\n  bottom?: number;\n  right?: number;\n  left?: number;\n  blur?: number;\n}\nexport interface IEmbedding {\n  model: string;\n  weight: number;\n}\nexport interface IipAdapter {\n  model: string;\n  weight: number;\n  guideImage: string;\n}\n\nexport interface IRefiner {\n  model: string;\n  startStep?: number;\n  startStepPercentage?: number;\n}\nexport interface IRequestImageToText extends IAdditionalResponsePayload {\n  inputImage?: File | string;\n  includeCost?: boolean;\n  customTaskUUID?: string;\n  retry?: number;\n}\nexport interface IImageToText {\n  taskType: ETaskType;\n  taskUUID: string;\n  text: string;\n  cost?: number;\n}\n\nexport interface IRemoveImageBackground extends IRequestImageToText {\n  outputType?: IOutputType;\n  outputFormat?: IOutputFormat;\n  model: string;\n  settings?: {\n    rgba?: number[];\n    postProcessMask?: boolean;\n    returnOnlyMask?: boolean;\n    alphaMatting?: boolean;\n    alphaMattingForegroundThreshold?: number;\n    alphaMattingBackgroundThreshold?: number;\n    alphaMattingErodeSize?: number;\n  };\n  includeCost?: boolean;\n  outputQuality?: number;\n  retry?: number;\n}\n\nexport interface IRequestVideo extends IRequestImageToText {\n  outputType?: IOutputType;\n  outputFormat?: IOutputFormat;\n  outputQuality?: number;\n  uploadEndpoint?: string;\n  checkNSFW?: boolean;\n  includeCost?: boolean;\n  positivePrompt: string;\n  negativePrompt?: string;\n  model: string;\n  steps?: number;\n  CFGScale?: number;\n  seed?: number;\n  duration?: number;\n  fps?: number;\n  width?: number;\n  height?: number;\n  numberResults?: number;\n\n  skipResponse?: boolean;\n  customTaskUUID?: string;\n  retry?: number;\n\n  [key: string]: any;\n}\nexport interface IAsyncResults {\n  taskUUID: string;\n  onPartialImages?: (images: IImage[], error?: IError) => void;\n}\n\nexport interface IRemoveImage {\n  taskType: ETaskType;\n  taskUUID: string;\n  imageUUID: string;\n  inputImageUUID: string;\n  imageURL?: string;\n  imageBase64Data?: string;\n  imageDataURI?: string;\n  cost?: number;\n}\n\nexport interface IPromptEnhancer extends IAdditionalResponsePayload {\n  promptMaxLength?: number;\n  promptVersions?: number;\n  prompt: string;\n  includeCost?: boolean;\n  customTaskUUID?: string;\n  retry?: number;\n}\n\nexport interface IEnhancedPrompt extends IImageToText {}\n\nexport interface IUpscaleGan extends IAdditionalResponsePayload {\n  inputImage: File | string;\n  upscaleFactor: number;\n  outputType?: IOutputType;\n  outputFormat?: IOutputFormat;\n  includeCost?: boolean;\n  outputQuality?: number;\n\n  customTaskUUID?: string;\n  retry?: number;\n}\n\nexport type ReconnectingWebsocketProps = {\n  addEventListener: (\n    type: string,\n    listener: EventListener,\n    options: any\n  ) => void;\n  send: (data: any) => void;\n} & WebSocket;\n\nexport type UploadImageType = {\n  imageURL: string;\n  imageUUID: string;\n  taskUUID: string;\n  taskType: ETaskType;\n};\n\nexport type GetWithPromiseCallBackType = ({\n  resolve,\n  reject,\n  intervalId,\n}: {\n  resolve: <T>(value: T) => void;\n  reject: <T>(value: T) => void;\n  intervalId: any;\n}) => boolean | undefined;\n\nexport type GetWithPromiseAsyncCallBackType = ({\n  resolve,\n  reject,\n  intervalId,\n}: {\n  resolve: <T>(value: T) => void;\n  reject: <T>(value: T) => void;\n  intervalId: any;\n}) => any;\n\nexport enum EPreProcessorGroup {\n  \"canny\" = \"canny\",\n  \"depth\" = \"depth\",\n  \"mlsd\" = \"mlsd\",\n  \"normalbae\" = \"normalbae\",\n  \"openpose\" = \"openpose\",\n  \"tile\" = \"tile\",\n  \"seg\" = \"seg\",\n  \"lineart\" = \"lineart\",\n  \"lineart_anime\" = \"lineart_anime\",\n  \"shuffle\" = \"shuffle\",\n  \"scribble\" = \"scribble\",\n  \"softedge\" = \"softedge\",\n}\n\nexport enum EPreProcessor {\n  \"canny\" = \"canny\",\n  \"depth_leres\" = \"depth_leres\",\n  \"depth_midas\" = \"depth_midas\",\n  \"depth_zoe\" = \"depth_zoe\",\n  \"inpaint_global_harmonious\" = \"inpaint_global_harmonious\",\n  \"lineart_anime\" = \"lineart_anime\",\n  \"lineart_coarse\" = \"lineart_coarse\",\n  \"lineart_realistic\" = \"lineart_realistic\",\n  \"lineart_standard\" = \"lineart_standard\",\n  \"mlsd\" = \"mlsd\",\n  \"normal_bae\" = \"normal_bae\",\n\n  \"scribble_hed\" = \"scribble_hed\",\n  \"scribble_pidinet\" = \"scribble_pidinet\",\n  \"seg_ofade20k\" = \"seg_ofade20k\",\n  \"seg_ofcoco\" = \"seg_ofcoco\",\n  \"seg_ufade20k\" = \"seg_ufade20k\",\n  \"shuffle\" = \"shuffle\",\n  \"softedge_hed\" = \"softedge_hed\",\n  \"softedge_hedsafe\" = \"softedge_hedsafe\",\n  \"softedge_pidinet\" = \"softedge_pidinet\",\n  \"softedge_pidisafe\" = \"softedge_pidisafe\",\n  \"tile_gaussian\" = \"tile_gaussian\",\n\n  \"openpose\" = \"openpose\",\n  \"openpose_face\" = \"openpose_face\",\n  \"openpose_faceonly\" = \"openpose_faceonly\",\n  \"openpose_full\" = \"openpose_full\",\n  \"openpose_hand\" = \"openpose_hand\",\n}\n\nexport enum EOpenPosePreProcessor {\n  \"openpose\" = \"openpose\",\n  \"openpose_face\" = \"openpose_face\",\n  \"openpose_faceonly\" = \"openpose_faceonly\",\n  \"openpose_full\" = \"openpose_full\",\n  \"openpose_hand\" = \"openpose_hand\",\n}\n\nexport type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<\n  T,\n  Exclude<keyof T, Keys>\n> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;\n  }[Keys];\n\nexport type RequireOnlyOne<T, Keys extends keyof T = keyof T> = Pick<\n  T,\n  Exclude<keyof T, Keys>\n> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> &\n      Partial<Record<Exclude<Keys, K>, undefined>>;\n  }[Keys];\n\nexport type ListenerType = {\n  key: string;\n  listener: (msg: any) => void;\n  groupKey?: string;\n};\n\nexport interface IAddModelResponse {\n  status: string;\n  message: string;\n  taskUUID: string;\n  air: string;\n  taskType: string;\n}\n\nexport interface IErrorResponse {\n  code: string;\n  message: string;\n  parameter: string;\n  type: string;\n  documentation: string;\n  taskUUID: string;\n  min?: number;\n  max?: number;\n  default?: string | number;\n}\n\nexport type TAddModelBaseType = {\n  air: string;\n  name: string;\n  downloadURL: string;\n  uniqueIdentifier: string;\n\n  version: string;\n  format: EModelFormat;\n  architecture: EModelArchitecture;\n  heroImageURL?: string;\n  tags?: string[];\n  shortDescription?: string;\n  comment?: string;\n  private: boolean;\n\n  // Custom parameters\n  customTaskUUID?: string;\n  retry?: number;\n  onUploadStream?: (\n    response?: IAddModelResponse,\n    error?: IErrorResponse\n  ) => void;\n};\n\nexport type TAddModelControlNet = {\n  category: \"controlnet\";\n  conditioning: EModelConditioning;\n} & TAddModelBaseType;\n\nexport type TAddModelCheckPoint = {\n  category: \"checkpoint\";\n  defaultCFGScale?: number;\n  defaultStrength: number;\n  defaultSteps?: number;\n  defaultScheduler?: string;\n  type: EModelType;\n} & TAddModelBaseType;\n\nexport type TAddModelLora = {\n  category: \"lora\";\n  defaultWeight: number;\n  positiveTriggerWords?: string;\n} & TAddModelBaseType;\n\nexport type TAddModel =\n  | TAddModelCheckPoint\n  | TAddModelControlNet\n  | TAddModelLora;\n\nexport type TPhotoMaker = {\n  style: EPhotoMakerEnum;\n  inputImages: string[];\n  outputType?: string;\n  outputFormat?: string;\n  uploadEndpoint?: string;\n  checkNSFW?: boolean;\n  positivePrompt: string;\n  negativePrompt?: string;\n  strength?: number;\n  height: number;\n  width: number;\n  model?: string; // this should be hidden for now cause we have a single model\n  steps?: number;\n  scheduler?: string;\n  seed?: number;\n  CFGScale?: number;\n  clipSkip?: number;\n  numberResults: number;\n  includeCost?: boolean;\n  outputQuality?: number;\n\n  // other options\n  customTaskUUID?: string;\n  retry?: number;\n  onPartialImages?: (images: IImage[], error?: IError) => void;\n} & IAdditionalResponsePayload;\n\nexport type TPhotoMakerResponse = {\n  taskType: string;\n  taskUUID: string;\n  imageUUID: string;\n  NSFWContent: boolean;\n  cost: number;\n  seed: number;\n  imageURL: string;\n  positivePrompt: string;\n  negativePrompt?: string;\n};\n\nexport enum EModelFormat {\n  safetensors = \"safetensors\",\n  pickletensor = \"pickletensor\",\n}\n\nexport enum EModelArchitecture {\n  flux1d = \"flux1d\",\n  flux1s = \"flux1s\",\n  pony = \"pony\",\n  sdhyper = \"sdhyper\",\n  sd1x = \"sd1x\",\n  sd1xlcm = \"sd1xlcm\",\n  sd3 = \"sd3\",\n  sdxl = \"sdxl\",\n  sdxllcm = \"sdxllcm\",\n  sdxldistilled = \"sdxldistilled\",\n  sdxlhyper = \"sdxlhyper\",\n  sdxllightning = \"sdxllightning\",\n  sdxlturbo = \"sdxlturbo\",\n}\n\nexport enum EModelType {\n  base = \"base\",\n  inpainting = \"inpainting\",\n  pix2pix = \"pix2pix\",\n}\n\nexport enum EModelConditioning {\n  canny = \"canny\",\n  depth = \"depth\",\n  qrcode = \"qrcode\",\n  hed = \"hed\",\n  scrible = \"scrible\",\n  openpose = \"openpose\",\n  seg = \"segmentation\",\n  openmlsd = \"openmlsd\",\n  softedge = \"softedge\",\n  normal = \"normal bae\",\n  shuffle = \"shuffle\",\n  pix2pix = \"pix2pix\",\n  inpaint = \"inpaint\",\n  lineart = \"line art\",\n  sketch = \"sketch\",\n  inpaintdepth = \"inpaint depth\",\n  tile = \"tile\",\n  outfit = \"outfit\",\n  blur = \"blur\",\n  gray = \"gray\",\n  lowquality = \"low quality\",\n}\n\nexport enum EPhotoMakerEnum {\n  NoStyle = \"No style\",\n  Cinematic = \"Cinematic\",\n  DisneyCharacter = \"Disney Character\",\n  DigitalArt = \"Digital Art\",\n  Photographic = \"Photographic\",\n  FantasyArt = \"Fantasy art\",\n  Neonpunk = \"Neonpunk\",\n  Enhance = \"Enhance\",\n  ComicBook = \"Comic book\",\n  Lowpoly = \"Lowpoly\",\n  LineArt = \"Line art\",\n}\n\nexport type TModelSearch = {\n  search?: string;\n  tags?: string[];\n  category?: \"checkpoint\" | \"lora\" | \"controlnet\";\n  type?: string;\n  architecture?: EModelArchitecture;\n  conditioning?: string;\n  visibility?: \"public\" | \"private\" | \"all\";\n  limit?: number;\n  offset?: number;\n\n  // other options\n  customTaskUUID?: string;\n  retry?: number;\n} & { [key: string]: any };\n\nexport type TModel = {\n  air: string;\n  name: string;\n  version: string;\n  category: string;\n  architecture: string;\n  tags: string[];\n  heroImage: string;\n  private: boolean;\n  comment: string;\n\n  // Optionals\n  type?: string;\n  defaultWidth?: number;\n  defaultHeight?: number;\n  defaultSteps?: number;\n  defaultScheduler?: string;\n  defaultCFG?: number;\n  defaultStrength: number;\n  conditioning?: string;\n  positiveTriggerWords?: string;\n} & { [key: string]: any };\n\nexport type TModelSearchResponse = {\n  results: TModel[];\n  taskUUID: string;\n  taskType: string;\n  totalResults: number;\n};\n\nexport type TImageMasking = {\n  model: string;\n  inputImage: string;\n  confidence?: number;\n  maskPadding?: number;\n  maskBlur?: number;\n  outputFormat?: string;\n  outputType?: string;\n  includeCost?: boolean;\n  uploadEndpoint?: string;\n  maxDetections?: number;\n  outputQuality?: number;\n\n  customTaskUUID?: string;\n  retry?: number;\n};\n\nexport type TImageUpload = {\n  image: string;\n\n  customTaskUUID?: string;\n  retry?: number;\n};\n\nexport type TImageUploadResponse = {\n  image: string;\n  taskUUID: string;\n  imageUUID: number;\n  imageURL: string;\n};\n\nexport type TImageMaskingResponse = {\n  taskType: string;\n  taskUUID: string;\n  maskImageUUID: string;\n\n  detections: [\n    {\n      x_min: number;\n      y_min: number;\n      x_max: number;\n      y_max: number;\n    }\n  ];\n  maskImageURL: string;\n  cost: number;\n};\n\nexport type TServerError = {\n  error: {\n    code: string;\n    message: string;\n    parameter: string;\n    type: string;\n    taskType: string;\n  };\n};\n","import {\n  EPreProcessor,\n  EPreProcessorGroup,\n  Environment,\n  GetWithPromiseAsyncCallBackType,\n  GetWithPromiseCallBackType,\n  IRequestImage,\n} from \"./types\";\nimport { v4 as uuidv4, validate as validateUUID } from \"uuid\";\n\nexport const TIMEOUT_DURATION = 60000; // 120S;\nexport const MINIMUM_TIMEOUT_DURATION = 1000; // 120S;\nconst POLLING_INTERVAL = 100; // 1s;\n\nexport const BASE_RUNWARE_URLS = {\n  [Environment.PRODUCTION]: \"wss://ws-api.runware.ai/v1\",\n  [Environment.TEST]: \"ws://localhost:8080\",\n};\n\nexport const removeFromAray = <T>(col: T[], targetElem: T) => {\n  if (col == null) {\n    return;\n  }\n  let i = col.indexOf(targetElem);\n  if (i === -1) {\n    return;\n  }\n  col.splice(i, 1);\n};\n\nexport const getIntervalWithPromise = (\n  callback: GetWithPromiseCallBackType,\n  {\n    debugKey = \"debugKey\",\n    timeoutDuration = TIMEOUT_DURATION,\n    shouldThrowError = true,\n    pollingInterval = POLLING_INTERVAL,\n  }: {\n    debugKey?: string;\n    timeoutDuration?: number;\n    shouldThrowError?: boolean;\n    pollingInterval?: number;\n  }\n) => {\n  timeoutDuration =\n    timeoutDuration < MINIMUM_TIMEOUT_DURATION\n      ? MINIMUM_TIMEOUT_DURATION\n      : timeoutDuration;\n\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      if (intervalId) {\n        clearInterval(intervalId);\n        if (shouldThrowError) {\n          reject(`Response could not be received from server for ${debugKey}`);\n        }\n      }\n      clearTimeout(timeoutId);\n      // reject();\n    }, timeoutDuration);\n\n    let intervalId = setInterval(async () => {\n      const shouldClear = callback({ resolve, reject, intervalId });\n\n      if (shouldClear) {\n        clearInterval(intervalId);\n        clearTimeout(timeoutId);\n      }\n      // resolve(imagesWithSimilarTask); // Resolve the promise with the data\n    }, pollingInterval); // Check every 1 second (adjust the interval as needed)\n  });\n};\n\nexport const fileToBase64 = (file: File) =>\n  new Promise((resolve) => {\n    const reader = new FileReader();\n    reader.readAsDataURL(file);\n    reader.onload = function () {\n      resolve(reader.result);\n    };\n  });\n\n// export const getUUID = () => crypto.randomUUID();\nexport const getUUID = () => uuidv4();\n\nexport const isValidUUID = (uuid: string) => validateUUID(uuid);\n\nconst evaluateToBoolean = (...args: any) => [...args].every((e) => !!e);\n\nexport const compact = (value: any, data: any) => (!!value ? data : {});\n\nexport const getPreprocessorType = (\n  processor: EPreProcessor\n): EPreProcessorGroup => {\n  const processorGroup = Object.keys(\n    EPreProcessorGroup\n  ) as EPreProcessorGroup[];\n\n  switch (processor) {\n    case EPreProcessor.canny:\n      return EPreProcessorGroup.canny;\n    // break\n    case EPreProcessor.depth_leres:\n    case EPreProcessor.depth_midas:\n    case EPreProcessor.depth_zoe:\n      return EPreProcessorGroup.depth;\n    // break\n    case EPreProcessor.inpaint_global_harmonious:\n      return EPreProcessorGroup.depth;\n    // break\n    case EPreProcessor.lineart_anime:\n      return EPreProcessorGroup.lineart_anime;\n    // break\n    case EPreProcessor.lineart_coarse:\n    case EPreProcessor.lineart_realistic:\n    case EPreProcessor.lineart_standard:\n      return EPreProcessorGroup.lineart;\n    // break\n    case EPreProcessor.mlsd:\n      return EPreProcessorGroup.mlsd;\n    // break\n    case EPreProcessor.normal_bae:\n      return EPreProcessorGroup.normalbae;\n    // break\n    case EPreProcessor.openpose_face:\n    case EPreProcessor.openpose_faceonly:\n    case EPreProcessor.openpose_full:\n    case EPreProcessor.openpose_hand:\n    case EPreProcessor.openpose:\n      return EPreProcessorGroup.openpose;\n    // break\n    case EPreProcessor.scribble_hed:\n    case EPreProcessor.scribble_pidinet:\n      return EPreProcessorGroup.scribble;\n    // break\n    case EPreProcessor.seg_ofade20k:\n    case EPreProcessor.seg_ofcoco:\n    case EPreProcessor.seg_ufade20k:\n      return EPreProcessorGroup.seg;\n    // break\n    case EPreProcessor.shuffle:\n      return EPreProcessorGroup.shuffle;\n    // break\n    case EPreProcessor.softedge_hed:\n    case EPreProcessor.softedge_hedsafe:\n    case EPreProcessor.softedge_pidinet:\n    case EPreProcessor.softedge_pidisafe:\n      return EPreProcessorGroup.softedge;\n    // break\n    case EPreProcessor.tile_gaussian:\n      return EPreProcessorGroup.tile;\n    // break\n    default:\n      return EPreProcessorGroup.canny;\n  }\n};\n\nexport const accessDeepObject = ({\n  key,\n  data,\n  useZero = true,\n  shouldReturnString = false,\n}: {\n  key: string;\n  data: Record<string, any>;\n  useZero?: boolean;\n  shouldReturnString?: boolean;\n}) => {\n  const splittedKeys = key.split(/\\.|\\[/).map((key) => key.replace(/\\]$/, \"\"));\n\n  const value = splittedKeys.reduce((acc, curr) => {\n    const returnZero = useZero ? 0 : undefined;\n    const currentValue = acc?.[curr];\n\n    if (!currentValue) {\n      return returnZero;\n    }\n    if (Array.isArray(currentValue) && /^\\d+$/.test(curr)) {\n      const index = parseInt(curr, 10);\n      if (index >= 0 && index < currentValue.length) {\n        return (acc[curr] = currentValue[index]);\n      } else {\n        return acc[curr] ?? returnZero;\n      }\n    } else {\n      return acc[curr] ?? returnZero;\n    }\n  }, data || {});\n\n  // if (typeof value === \"object\" && shouldReturnString) {\n  //   return JSON.stringify(value);\n  // }\n  return value ?? {};\n};\n\nexport const delay = (time: number, milliseconds = 1000) => {\n  return new Promise((resolve) => setTimeout(resolve, time * milliseconds));\n};\n\nexport class MockFile {\n  create = function (name: string, size: number, mimeType: string) {\n    name = name || \"mock.txt\";\n    size = size || 1024;\n    mimeType = mimeType || \"plain/txt\";\n\n    var blob: any = new Blob([range(size)], { type: mimeType });\n    blob.lastModifiedDate = new Date();\n    blob.name = name;\n\n    return blob;\n  };\n}\n\nfunction range(count: number) {\n  var output = \"\";\n  for (var i = 0; i < count; i++) {\n    output += \"a\";\n  }\n  return output;\n}\n\nexport const RETRY_SDK_COUNTS = {\n  GLOBAL: 2,\n  REQUEST_IMAGES: 2,\n};\n\nexport const remove1Mutate = (col: any, targetElem: any) => {\n  if (col == null) {\n    return;\n  }\n\n  let i = col.indexOf(targetElem);\n  if (i === -1) {\n    return;\n  }\n  col.splice(i, 1);\n};\n\nexport const removeListener = (listeners: any[], listener: any) => {\n  return listeners.filter((lis) => lis.key !== listener.key);\n};\n\nexport const removeAllKeyListener = ({\n  listeners,\n  key,\n}: {\n  listeners: any[];\n  key: any;\n}) => {\n  return listeners.filter((lis) => lis?.key !== key);\n};\n\nexport enum LISTEN_TO_IMAGES_KEY {\n  REQUEST_IMAGES = \"REQUEST_IMAGES\",\n}\n\nexport const evaluateNonTrue = ({\n  key,\n  value,\n}: {\n  key: string;\n  value: any;\n}) => {\n  if (!!value || value === 0 || value === false) {\n    return { [key]: value };\n  } else {\n    return {};\n  }\n};\n\nexport const getRandomNumber = (min: number, max: number) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nexport const getRandomSeed = () => {\n  return getRandomNumber(1, Number.MAX_SAFE_INTEGER);\n};\n\nexport const getRandomTaskResponses = ({\n  count,\n  taskUUID,\n}: {\n  count: number;\n  taskUUID: string;\n}) => {\n  const responses = [];\n\n  for (let i = 0; i < count; i++) {\n    const isSucceeded = Math.random() < 0.5; // 50% chance\n\n    const base = {\n      taskUUID,\n      taskType: \"videoInference\",\n    };\n\n    if (isSucceeded) {\n      responses.push({\n        ...base,\n        status: \"succeeded\",\n        videoUUID: crypto.randomUUID(),\n        cost: parseFloat((Math.random() * 10).toFixed(2)),\n        seed: Math.floor(Math.random() * 100),\n        videoURL: getRandomVideoURL(),\n      });\n    } else {\n      responses.push({\n        ...base,\n        status: \"pending\",\n      });\n    }\n  }\n\n  return responses;\n};\n\nconst SAMPLE_VIDEO_URLS = [\n  \"https://vm.runware.dev/video/ws/2/vi/032dd763-4082-4fa4-aa7c-ca2e0d272c08.mp4\",\n  \"https://vm.runware.dev/video/ws/2/vi/4f809a60-47bb-49e7-9a31-c8834a8bf143.mp4\",\n  \"https://vm.runware.dev/video/ws/2/vi/3a146615-5ba6-4844-9d54-6455617554f8.mp4\", // from Pixabay\n  \"https://www.w3schools.com/html/mov_bbb.mp4\", // Big Buck Bunny sample\n  \"https://filesamples.com/samples/video/mp4/sample_640x360.mp4\",\n  \"https://media.w3.org/2010/05/sintel/trailer.mp4\",\n  \"https://samplelib.com/lib/preview/mp4/sample-5s.mp4\",\n  \"https://test-videos.co.uk/vids/bigbuckbunny/mp4/h264/720/Big_Buck_Bunny_720_10s_1MB.mp4\",\n];\n\nfunction getRandomVideoURL() {\n  const index = Math.floor(Math.random() * SAMPLE_VIDEO_URLS.length);\n  return SAMPLE_VIDEO_URLS[index];\n}\n\nexport const getIntervalAsyncWithPromise = (\n  callback: GetWithPromiseAsyncCallBackType,\n  {\n    debugKey = \"debugKey\",\n    timeoutDuration = TIMEOUT_DURATION,\n    shouldThrowError = true,\n    pollingInterval = POLLING_INTERVAL,\n  }: {\n    debugKey?: string;\n    timeoutDuration?: number;\n    shouldThrowError?: boolean;\n    pollingInterval?: number;\n  }\n) => {\n  timeoutDuration =\n    timeoutDuration < MINIMUM_TIMEOUT_DURATION\n      ? MINIMUM_TIMEOUT_DURATION\n      : timeoutDuration;\n\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      if (intervalId) {\n        clearInterval(intervalId);\n        if (shouldThrowError) {\n          reject(`Response could not be received from server for ${debugKey}`);\n        }\n      }\n      clearTimeout(timeoutId);\n    }, timeoutDuration);\n\n    let intervalId = setInterval(async () => {\n      try {\n        const shouldClear = await callback({ resolve, reject, intervalId });\n        if (shouldClear) {\n          clearInterval(intervalId);\n          clearTimeout(timeoutId);\n        }\n      } catch (error) {\n        clearInterval(intervalId);\n        clearTimeout(timeoutId);\n        reject(error);\n      }\n    }, pollingInterval);\n  });\n};\n","import { delay } from \"./utils\";\n\nexport const asyncRetry = async (\n  apiCall: Function,\n  options: {\n    maxRetries?: number;\n    delayInSeconds?: number;\n    callback?: Function;\n  } = {}\n) => {\n  const { delayInSeconds = 1, callback } = options;\n  let maxRetries = options.maxRetries ?? 1;\n  while (maxRetries) {\n    try {\n      const result = await apiCall();\n      return result; // Return the result if successful\n    } catch (error: any) {\n      callback?.();\n      if (error?.error) {\n        throw error;\n      }\n      maxRetries--;\n      if (maxRetries > 0) {\n        await delay(delayInSeconds); // Delay before the next retry\n        await asyncRetry(apiCall, { ...options, maxRetries });\n      } else {\n        throw error; // Throw the error if max retries are reached\n      }\n    }\n  }\n};\n","// @ts-ignore\nimport { asyncRetry } from \"./async-retry\";\nimport {\n  EControlMode,\n  IControlNet,\n  IControlNetWithUUID,\n  IEnhancedPrompt,\n  IError,\n  IImage,\n  IImageToText,\n  IPromptEnhancer,\n  IRemoveImageBackground,\n  IRequestImage,\n  IRequestImageToText,\n  IUpscaleGan,\n  ListenerType,\n  ReconnectingWebsocketProps,\n  RunwareBaseType,\n  SdkType,\n  UploadImageType,\n  ETaskType,\n  IControlNetPreprocess,\n  IControlNetImage,\n  IRemoveImage,\n  ITextToImage,\n  TAddModel,\n  IAddModelResponse,\n  IErrorResponse,\n  TPhotoMaker,\n  TPhotoMakerResponse,\n  TModelSearch,\n  TImageMaskingResponse,\n  TImageMasking,\n  TModelSearchResponse,\n  TServerError,\n  TImageUpload,\n  TImageUploadResponse,\n  IRequestVideo,\n  IAsyncResults,\n  IVideoToImage,\n} from \"./types\";\nimport {\n  BASE_RUNWARE_URLS,\n  LISTEN_TO_IMAGES_KEY,\n  TIMEOUT_DURATION,\n  accessDeepObject,\n  delay,\n  evaluateNonTrue,\n  fileToBase64,\n  getIntervalAsyncWithPromise,\n  getIntervalWithPromise,\n  getRandomSeed,\n  getUUID,\n  isValidUUID,\n  removeFromAray,\n  removeListener,\n} from \"./utils\";\n\n// let allImages: IImage[] = [];\n\nexport class RunwareBase {\n  _ws: ReconnectingWebsocketProps | any;\n  _listeners: ListenerType[] = [];\n  _apiKey: string;\n  _url?: string;\n  // _globalMessages: any[] = [];\n  _globalMessages: Record<string, any> = {};\n  _globalImages: IImage[] = [];\n  _globalError: IError | undefined;\n  _connectionSessionUUID: string | undefined;\n  _connectionError: TServerError | undefined;\n  _sdkType: SdkType;\n  _shouldReconnect: boolean;\n  _globalMaxRetries: number;\n  _timeoutDuration: number;\n  ensureConnectionUUID: string | null = null;\n\n  constructor({\n    apiKey,\n    url = BASE_RUNWARE_URLS.PRODUCTION,\n    shouldReconnect = true,\n    globalMaxRetries = 2,\n    timeoutDuration = TIMEOUT_DURATION,\n  }: RunwareBaseType) {\n    this._apiKey = apiKey;\n    this._url = url;\n    this._sdkType = SdkType.CLIENT;\n    this._shouldReconnect = shouldReconnect;\n    this._globalMaxRetries = globalMaxRetries;\n    this._timeoutDuration = timeoutDuration;\n  }\n\n  static async initialize(props: RunwareBaseType) {\n    try {\n      const instance = new this(props);\n      await instance.ensureConnection();\n      return instance;\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  protected isWebsocketReadyState = () => this._ws?.readyState === 1;\n\n  // protected addListener({\n  //   lis,\n  //   check,\n  // }: {\n  //   lis: (v: any) => any;\n  //   check: (v: any) => any;\n  //   groupKey?: string;\n  // }): { destroy: Function } {\n  //   this._ws.onmessage = (e: any) => {\n  //     const m = JSON.parse(e.data);\n\n  //     if (m?.error) {\n  //       lis(m);\n  //     } else if (check(m)) {\n  //       lis(m);\n  //     }\n  //   };\n\n  //   return\n  //     destroy: () => {},\n  //   };\n  // }\n\n  protected isInvalidAPIKey = () => {\n    return this._connectionError?.error?.code === \"invalidApiKey\";\n  };\n\n  protected addListener({\n    lis,\n    // check,\n    groupKey,\n    taskUUID,\n  }: {\n    lis: (v: any) => any;\n    // check: ETaskType;\n    groupKey?: string;\n    taskUUID: string;\n  }) {\n    const listener = (msg: {\n      data: any[];\n      errors?: { taskUUID: string; code: string; taskType?: string }[];\n      errorMessage?: string;\n    }) => {\n      const arrayMessage = Array.isArray(msg?.data) ? msg.data : [msg.data];\n\n      const arrayErrors = (msg as any)?.[0]?.errors\n        ? (msg as any)?.[0]?.errors\n        : Array.isArray(msg?.errors)\n        ? msg.errors\n        : [msg.errors];\n\n      const filteredMessage = arrayMessage.filter(\n        (v) => (v?.taskUUID || v?.taskType) === taskUUID\n      );\n\n      const filteredErrors = arrayErrors.filter(\n        (v: any) => (v?.taskUUID || v?.taskType) === taskUUID\n      );\n\n      if (filteredErrors.length) {\n        lis({ error: { ...(arrayErrors[0] ?? {}) } });\n        return;\n      }\n\n      if (filteredMessage.length) {\n        lis({ [taskUUID]: arrayMessage });\n        return;\n      }\n    };\n    const groupListener = { key: taskUUID || getUUID(), listener, groupKey };\n    this._listeners.push(groupListener);\n    const destroy = () => {\n      this._listeners = removeListener(this._listeners, groupListener);\n    };\n\n    return {\n      destroy,\n    };\n  }\n\n  protected connect() {\n    this._ws.onopen = (e: any) => {\n      if (this._connectionSessionUUID) {\n        this.send({\n          taskType: ETaskType.AUTHENTICATION,\n          apiKey: this._apiKey,\n          connectionSessionUUID: this._connectionSessionUUID,\n        });\n      } else {\n        this.send({ apiKey: this._apiKey, taskType: ETaskType.AUTHENTICATION });\n      }\n\n      this.addListener({\n        taskUUID: ETaskType.AUTHENTICATION,\n        lis: (m) => {\n          if (m?.error) {\n            this._connectionError = m;\n            return;\n          }\n          this._connectionSessionUUID =\n            m?.[ETaskType.AUTHENTICATION]?.[0]?.connectionSessionUUID;\n          this._connectionError = undefined;\n        },\n      });\n    };\n\n    this._ws.onmessage = (e: any) => {\n      const data = JSON.parse(e.data);\n      for (const lis of this._listeners) {\n        const result = (lis as any)?.listener?.(data);\n        if (result) return;\n      }\n    };\n\n    this._ws.onclose = (e: any) => {\n      // console.log(\"closing\");\n      // console.log(\"invalid\", this._invalidAPIkey);\n      if (this.isInvalidAPIKey()) {\n        return;\n      }\n    };\n  }\n\n  // We moving to an array format, it make sense to consolidate all request to an array here\n  protected send = (msg: Object) => {\n    this._ws.send(JSON.stringify([msg]));\n  };\n\n  private destroy(lis: any) {\n    removeFromAray(this._listeners, lis);\n  }\n\n  private uploadImage = async (\n    file: File | string\n  ): Promise<UploadImageType | null> => {\n    try {\n      return await asyncRetry(async () => {\n        const taskUUID = getUUID();\n\n        if (typeof file === \"string\" && isValidUUID(file)) {\n          return {\n            imageURL: file,\n            imageUUID: file,\n            taskUUID,\n            taskType: ETaskType.IMAGE_UPLOAD,\n          };\n        }\n\n        const imageBase64 =\n          typeof file === \"string\" ? file : await fileToBase64(file);\n\n        return {\n          imageURL: imageBase64,\n          imageUUID: imageBase64,\n          taskUUID,\n          taskType: ETaskType.IMAGE_UPLOAD,\n        };\n      });\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  private listenToImages({\n    onPartialImages,\n    taskUUID,\n    groupKey,\n    requestPayload,\n    startTime,\n  }: {\n    taskUUID: string;\n    onPartialImages?: (images: IImage[], error?: any) => void;\n    groupKey: LISTEN_TO_IMAGES_KEY;\n    requestPayload?: Record<string, any>;\n    startTime?: number;\n  }) {\n    return this.addListener({\n      taskUUID: taskUUID,\n      lis: (m) => {\n        let images = (m?.[taskUUID] as IImage[])?.filter(\n          (img) => img.taskUUID === taskUUID\n        );\n\n        if (m.error) {\n          onPartialImages?.(images, m?.error && m);\n          this._globalError = m;\n        } else {\n          images = images.map((image) => {\n            this.insertAdditionalResponse({\n              response: image,\n              payload: requestPayload ? requestPayload : undefined,\n              startTime: startTime ? startTime : undefined,\n            });\n\n            return {\n              ...image,\n            };\n          });\n          onPartialImages?.(images, m?.error && m);\n\n          if (this._sdkType === SdkType.CLIENT) {\n            // this._globalImages = [...this._globalImages, ...m.images];\n            this._globalImages = [\n              ...this._globalImages,\n              ...(m?.[taskUUID] ?? []).map((image: IImage) => {\n                this.insertAdditionalResponse({\n                  response: image,\n                  payload: requestPayload ? requestPayload : undefined,\n                  startTime: startTime ? startTime : undefined,\n                });\n\n                return {\n                  ...image,\n                };\n              }),\n            ];\n          } else {\n            this._globalImages = [...this._globalImages, ...images];\n          }\n        }\n      },\n      groupKey,\n    });\n  }\n\n  private listenToUpload({\n    onUploadStream,\n    taskUUID,\n  }: {\n    taskUUID: string;\n    onUploadStream?: (\n      addModelResponse?: IAddModelResponse,\n      error?: IErrorResponse\n    ) => void;\n  }) {\n    return this.addListener({\n      taskUUID: taskUUID,\n      lis: (m) => {\n        const error = m?.error;\n\n        const result = m?.[taskUUID]?.[0] as IAddModelResponse;\n        let response = result?.taskUUID === taskUUID ? result : null;\n\n        if (response || error) {\n          onUploadStream?.(response || undefined, error);\n        }\n      },\n    });\n  }\n\n  private globalListener({ taskUUID }: { taskUUID: string }) {\n    return this.addListener({\n      // check: (m) => {\n      //   const value = accessDeepObject({\n      //     key: responseKey,\n      //     data: m,\n      //     useZero: false,\n      //   });\n      //   return !!value;\n      // },\n      // check: responseKey,\n      taskUUID: taskUUID,\n      lis: (m) => {\n        if (m.error) {\n          this._globalMessages[taskUUID] = m;\n          return;\n        }\n\n        // console.log(\"m\", m);\n\n        const value = accessDeepObject({\n          key: taskUUID,\n          data: m,\n          useZero: false,\n        });\n        // console.log({ value });\n\n        if (Array.isArray(value)) {\n          value.forEach((v) => {\n            this._globalMessages[v.taskUUID] = [\n              ...(this._globalMessages[v.taskUUID] ?? []),\n              v,\n            ];\n          });\n        } else {\n          this._globalMessages[value.taskUUID] = value;\n        }\n      },\n    });\n  }\n\n  // includePayload?: boolean\n  // includeGenerationTime?: boolean\n\n  async requestImages(\n    {\n      outputType,\n      outputFormat,\n      uploadEndpoint,\n      checkNSFW,\n      positivePrompt,\n      negativePrompt,\n      seedImage,\n      maskImage,\n      strength,\n      height,\n      width,\n      model,\n      steps,\n      scheduler,\n      seed,\n      CFGScale,\n      clipSkip,\n      usePromptWeighting,\n      promptWeighting,\n      numberResults = 1,\n      onPartialImages,\n      includeCost,\n      customTaskUUID,\n      retry,\n      refiner,\n      maskMargin,\n      outputQuality,\n      controlNet,\n      lora,\n      embeddings,\n      ipAdapters,\n      outpaint,\n      acceleratorOptions,\n      advancedFeatures,\n      referenceImages,\n      includeGenerationTime,\n      includePayload,\n    }: // imageSize,\n    // gScale,\n    IRequestImage,\n    moreOptions?: Record<string, any>\n  ): Promise<ITextToImage[] | undefined> {\n    let lis: any = undefined;\n    let requestObject: Record<string, any> | undefined = undefined;\n    let taskUUIDs: string[] = [];\n    let retryCount = 0;\n\n    const totalRetry = retry || this._globalMaxRetries;\n\n    try {\n      await this.ensureConnection();\n\n      let seedImageUUID: string | null = null;\n      let maskImageUUID: string | null = null;\n      let controlNetData: IControlNetWithUUID[] = [];\n\n      if (seedImage) {\n        const uploadedImage = await this.uploadImage(seedImage);\n\n        if (!uploadedImage) return [];\n        seedImageUUID = uploadedImage.imageUUID;\n      }\n      if (maskImage) {\n        const uploadedMaskInitiator = await this.uploadImage(maskImage);\n        if (!uploadedMaskInitiator) return [];\n        maskImageUUID = uploadedMaskInitiator.imageUUID;\n      }\n\n      if (controlNet?.length) {\n        for (let i = 0; i < controlNet.length; i++) {\n          const controlData: IControlNet = controlNet[i];\n          const {\n            endStep,\n            startStep,\n            weight,\n            guideImage,\n            controlMode,\n            startStepPercentage,\n            endStepPercentage,\n            model: controlNetModel,\n          } = controlData;\n\n          const imageUploaded = guideImage\n            ? await this.uploadImage(guideImage as File | string)\n            : null;\n\n          controlNetData.push({\n            guideImage: imageUploaded?.imageUUID,\n            model: controlNetModel,\n            endStep,\n            startStep,\n            weight,\n            ...evaluateNonTrue({\n              key: \"startStepPercentage\",\n              value: startStepPercentage,\n            }),\n            ...evaluateNonTrue({\n              key: \"endStepPercentage\",\n              value: endStepPercentage,\n            }),\n            controlMode: controlMode || EControlMode.CONTROL_NET,\n          });\n        }\n      }\n\n      requestObject = {\n        taskType: ETaskType.IMAGE_INFERENCE,\n        model,\n        positivePrompt: positivePrompt,\n        ...(negativePrompt ? { negativePrompt } : {}),\n        ...(height ? { height } : {}),\n        ...(width ? { width } : {}),\n        numberResults,\n\n        ...(outputType ? { outputType } : {}),\n        ...(outputFormat ? { outputFormat } : {}),\n        ...(uploadEndpoint ? { uploadEndpoint } : {}),\n        ...evaluateNonTrue({ key: \"checkNSFW\", value: checkNSFW }),\n        ...evaluateNonTrue({ key: \"strength\", value: strength }),\n        ...evaluateNonTrue({ key: \"CFGScale\", value: CFGScale }),\n        ...evaluateNonTrue({ key: \"clipSkip\", value: clipSkip }),\n        ...evaluateNonTrue({ key: \"maskMargin\", value: maskMargin }),\n        ...evaluateNonTrue({\n          key: \"usePromptWeighting\",\n          value: usePromptWeighting,\n        }),\n        ...evaluateNonTrue({ key: \"steps\", value: steps }),\n        ...(promptWeighting ? { promptWeighting } : {}),\n        ...(seed ? { seed: seed } : { seed: getRandomSeed() }),\n        ...(scheduler ? { scheduler } : {}),\n        ...(refiner ? { refiner } : {}),\n        ...(outpaint ? { outpaint } : {}),\n        ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n        ...(seedImageUUID ? { seedImage: seedImageUUID } : {}),\n        ...(maskImageUUID ? { maskImage: maskImageUUID } : {}),\n        ...(outputQuality ? { outputQuality } : {}),\n        ...(controlNetData.length ? { controlNet: controlNetData } : {}),\n        ...(lora?.length ? { lora: lora } : {}),\n        ...(embeddings?.length ? { embeddings } : {}),\n        ...(ipAdapters?.length ? { ipAdapters } : {}),\n        ...(acceleratorOptions ? { acceleratorOptions } : {}),\n        ...(advancedFeatures ? { advancedFeatures } : {}),\n        ...(referenceImages?.length ? { referenceImages } : {}),\n        ...(moreOptions ?? {}),\n      };\n\n      const startTime = Date.now();\n\n      return await asyncRetry(\n        async () => {\n          retryCount++;\n          lis?.destroy();\n          const imagesWithSimilarTask = this._globalImages.filter((img) =>\n            taskUUIDs.includes(img.taskUUID)\n          );\n\n          const taskUUID = customTaskUUID || getUUID();\n\n          taskUUIDs.push(taskUUID);\n\n          const imageRemaining = numberResults - imagesWithSimilarTask.length;\n\n          const newRequestObject = {\n            ...requestObject,\n            taskUUID: taskUUID,\n            numberResults: imageRemaining,\n          };\n          this.send(newRequestObject);\n\n          // const generationTime = endTime - startTime;\n\n          lis = this.listenToImages({\n            onPartialImages,\n            taskUUID: taskUUID,\n            groupKey: LISTEN_TO_IMAGES_KEY.REQUEST_IMAGES,\n            requestPayload: includePayload ? newRequestObject : undefined,\n            startTime: includeGenerationTime ? startTime : undefined,\n          });\n\n          const promise = await this.getSimilarImages({\n            taskUUID: taskUUIDs,\n            numberResults,\n            lis,\n          });\n\n          lis.destroy();\n\n          return promise;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      if (retryCount >= totalRetry) {\n        return this.handleIncompleteImages({ taskUUIDs, error: e });\n      }\n      throw e;\n    }\n  }\n\n  controlNetPreProcess = async ({\n    inputImage,\n    preProcessorType,\n    height,\n    width,\n    outputType,\n    outputFormat,\n    highThresholdCanny,\n    lowThresholdCanny,\n    includeHandsAndFaceOpenPose,\n    includeCost,\n    outputQuality,\n    customTaskUUID,\n    retry,\n    includeGenerationTime,\n    includePayload,\n  }: IControlNetPreprocess): Promise<IControlNetImage | null> => {\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    const startTime = Date.now();\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          const image = await this.uploadImage(inputImage);\n          if (!image?.imageUUID) return null;\n\n          const taskUUID = customTaskUUID || getUUID();\n          const payload = {\n            inputImage: image.imageUUID,\n            taskType: ETaskType.IMAGE_CONTROL_NET_PRE_PROCESS,\n            taskUUID,\n            preProcessorType,\n            ...evaluateNonTrue({ key: \"height\", value: height }),\n            ...evaluateNonTrue({ key: \"width\", value: width }),\n            ...evaluateNonTrue({ key: \"outputType\", value: outputType }),\n            ...evaluateNonTrue({ key: \"outputFormat\", value: outputFormat }),\n            ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n            ...evaluateNonTrue({\n              key: \"highThresholdCanny\",\n              value: highThresholdCanny,\n            }),\n            ...evaluateNonTrue({\n              key: \"lowThresholdCanny\",\n              value: lowThresholdCanny,\n            }),\n            ...evaluateNonTrue({\n              key: \"includeHandsAndFaceOpenPose\",\n              value: includeHandsAndFaceOpenPose,\n            }),\n            ...(outputQuality ? { outputQuality } : {}),\n          };\n\n          this.send({\n            ...payload,\n          });\n          lis = this.globalListener({\n            taskUUID,\n          });\n\n          const guideImage = (await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              const uploadedImage = this.getSingleMessage({\n                taskUUID,\n              });\n\n              if (!uploadedImage) return;\n\n              if (uploadedImage?.error) {\n                reject(uploadedImage);\n                return true;\n              }\n\n              if (uploadedImage) {\n                // delete this._globalMessages[taskUUID];\n                resolve(uploadedImage);\n                return true;\n              }\n            },\n            {\n              debugKey: \"unprocessed-image\",\n              timeoutDuration: this._timeoutDuration,\n            }\n          )) as IControlNetImage;\n\n          lis.destroy();\n\n          this.insertAdditionalResponse({\n            response: guideImage,\n            payload: includePayload ? payload : undefined,\n            startTime: includeGenerationTime ? startTime : undefined,\n          });\n\n          return guideImage;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e: any) {\n      throw e;\n    }\n  };\n\n  requestImageToText = async ({\n    inputImage,\n    includeCost,\n    customTaskUUID,\n    retry,\n    includePayload,\n    includeGenerationTime,\n  }: IRequestImageToText): Promise<IImageToText> => {\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    const startTime = Date.now();\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          const imageUploaded = inputImage\n            ? await this.uploadImage(inputImage as File | string)\n            : null;\n\n          const taskUUID = customTaskUUID || getUUID();\n\n          const payload = {\n            taskUUID,\n            taskType: ETaskType.IMAGE_CAPTION,\n            inputImage: imageUploaded?.imageUUID,\n            ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n          };\n\n          this.send(payload);\n\n          lis = this.globalListener({\n            taskUUID,\n          });\n\n          const response = await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              const newReverseClip = this.getSingleMessage({\n                taskUUID,\n              });\n\n              if (!newReverseClip) return;\n\n              if (newReverseClip?.error) {\n                reject(newReverseClip);\n                return true;\n              }\n\n              if (newReverseClip) {\n                delete this._globalMessages[taskUUID];\n                resolve(newReverseClip);\n                return true;\n              }\n            },\n            {\n              debugKey: \"remove-image-background\",\n              timeoutDuration: this._timeoutDuration,\n            }\n          );\n\n          lis.destroy();\n\n          this.insertAdditionalResponse({\n            response: response,\n            payload: includePayload ? payload : undefined,\n            startTime: includeGenerationTime ? startTime : undefined,\n          });\n\n          return response as IImageToText;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  removeImageBackground = async (\n    payload: IRemoveImageBackground\n  ): Promise<IRemoveImage> => {\n    return this.baseSingleRequest({\n      payload: {\n        ...payload,\n        taskType: ETaskType.IMAGE_BACKGROUND_REMOVAL,\n      },\n      debugKey: \"remove-image-background\",\n    });\n  };\n\n  videoInference = async (\n    payload: IRequestVideo\n  ): Promise<IVideoToImage[] | IVideoToImage> => {\n    const { skipResponse, ...rest } = payload;\n    try {\n      const request = await this.baseSingleRequest<IVideoToImage>({\n        payload: {\n          ...rest,\n          deliveryMethod: \"async\",\n          taskType: ETaskType.VIDEO_INFERENCE,\n        },\n\n        debugKey: \"video-inference\",\n      });\n\n      if (skipResponse) {\n        return request;\n      }\n\n      const taskUUID = request?.taskUUID;\n\n      const numberResults = payload?.numberResults ?? 1;\n\n      const allVideos = new Map<string, any>();\n\n      await getIntervalAsyncWithPromise(\n        async ({ resolve, reject }) => {\n          try {\n            const videos = await this.getResponse({ taskUUID });\n\n            // Add videos to the collection\n            for (const video of videos || []) {\n              if (video.videoUUID) {\n                allVideos.set(video.videoUUID, video);\n              }\n            }\n\n            // Check completion AFTER updating the collection\n            const isComplete = allVideos.size === numberResults;\n\n            if (isComplete) {\n              resolve(Array.from(allVideos.values()));\n              return true; // Signal to clear the interval\n            }\n\n            return false; // Continue polling\n          } catch (err) {\n            reject(err);\n            return true; // Signal to clear the interval on error\n          }\n        },\n        {\n          debugKey: \"async-response\",\n          pollingInterval: 2 * 1000,\n          timeoutDuration: 10 * 60 * 1000,\n        }\n      );\n      return Array.from(allVideos.values());\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  getResponse = async (payload: IAsyncResults): Promise<IVideoToImage[]> => {\n    const taskUUID = payload.taskUUID;\n    // const mock = getRandomTaskResponses({ count: 2, taskUUID });\n    return this.baseSingleRequest({\n      payload: {\n        ...payload,\n        customTaskUUID: taskUUID,\n        taskType: ETaskType.GET_RESPONSE,\n      },\n      isMultiple: true,\n      debugKey: \"async-results\",\n    });\n  };\n\n  upscaleGan = async ({\n    inputImage,\n    upscaleFactor,\n    outputType,\n    outputFormat,\n    includeCost,\n    outputQuality,\n    customTaskUUID,\n    retry,\n    includeGenerationTime,\n    includePayload,\n  }: IUpscaleGan): Promise<IImage> => {\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    const startTime = Date.now();\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          let imageUploaded;\n\n          imageUploaded = await this.uploadImage(inputImage as File | string);\n\n          const taskUUID = customTaskUUID || getUUID();\n          const payload = {\n            taskUUID,\n            inputImage: imageUploaded?.imageUUID,\n            taskType: ETaskType.IMAGE_UPSCALE,\n            upscaleFactor,\n            ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n            ...(outputType ? { outputType } : {}),\n            ...(outputQuality ? { outputQuality } : {}),\n            ...(outputFormat ? { outputFormat } : {}),\n          };\n\n          this.send(payload);\n\n          lis = this.globalListener({\n            taskUUID,\n          });\n\n          const response = await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              const newUpscaleGan = this.getSingleMessage({ taskUUID });\n              if (!newUpscaleGan) return;\n\n              if (newUpscaleGan?.error) {\n                reject(newUpscaleGan);\n                return true;\n              }\n\n              if (newUpscaleGan) {\n                delete this._globalMessages[taskUUID];\n                resolve(newUpscaleGan);\n                return true;\n              }\n            },\n            { debugKey: \"upscale-gan\", timeoutDuration: this._timeoutDuration }\n          );\n\n          lis.destroy();\n\n          this.insertAdditionalResponse({\n            response,\n            payload: includePayload ? payload : undefined,\n            startTime: includeGenerationTime ? startTime : undefined,\n          });\n\n          return response as IImage;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  enhancePrompt = async ({\n    prompt,\n    promptMaxLength = 380,\n    promptVersions = 1,\n    includeCost,\n    customTaskUUID,\n    retry,\n    includeGenerationTime,\n    includePayload,\n  }: IPromptEnhancer): Promise<IEnhancedPrompt[]> => {\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    const startTime = Date.now();\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          const taskUUID = customTaskUUID || getUUID();\n\n          const payload = {\n            prompt,\n            taskUUID,\n            promptMaxLength,\n            promptVersions,\n            ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n            taskType: ETaskType.PROMPT_ENHANCE,\n          };\n\n          this.send(payload);\n\n          lis = this.globalListener({\n            taskUUID,\n          });\n\n          const response = await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              const reducedPrompt: IEnhancedPrompt[] =\n                this._globalMessages[taskUUID];\n\n              if ((reducedPrompt as any)?.error) {\n                reject(reducedPrompt as any);\n                return true;\n              }\n\n              if (reducedPrompt?.length >= promptVersions) {\n                delete this._globalMessages[taskUUID];\n                resolve(reducedPrompt);\n                return true;\n              }\n            },\n            {\n              debugKey: \"enhance-prompt\",\n              timeoutDuration: this._timeoutDuration,\n            }\n          );\n\n          lis.destroy();\n\n          this.insertAdditionalResponse({\n            response: response,\n            payload: includePayload ? payload : undefined,\n            startTime: includeGenerationTime ? startTime : undefined,\n          });\n          return response as IEnhancedPrompt[];\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  modelUpload = async (payload: TAddModel) => {\n    // This is written to destructure the payload from the additional parameters\n    const { onUploadStream, retry, customTaskUUID, ...addModelPayload } =\n      payload;\n\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          const taskUUID = customTaskUUID || getUUID();\n\n          this.send({\n            ...addModelPayload,\n            taskUUID,\n            taskType: ETaskType.MODEL_UPLOAD,\n          });\n\n          let result: IAddModelResponse;\n          let errorResult: IErrorResponse;\n\n          lis = this.listenToUpload({\n            taskUUID,\n            onUploadStream: (response, error) => {\n              onUploadStream?.(response, error);\n              if (response?.status === \"ready\") {\n                result = response;\n              } else if (error) {\n                errorResult = error;\n              }\n            },\n          });\n\n          const modelUploadResponse = await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              if (result) {\n                resolve(result);\n                return true;\n              } else if (errorResult) {\n                reject(errorResult);\n                return false;\n              }\n            },\n            {\n              shouldThrowError: false,\n              timeoutDuration: 60 * 60 * 1000,\n            }\n          );\n\n          return modelUploadResponse as IAddModelResponse | IErrorResponse;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  photoMaker = async (\n    payload: TPhotoMaker,\n    moreOptions?: Record<string, any>\n  ): Promise<TPhotoMakerResponse[] | undefined> => {\n    // This is written to destructure the payload from the additional parameters\n    const {\n      onPartialImages,\n      retry,\n      customTaskUUID,\n      numberResults,\n      includeGenerationTime,\n      includePayload,\n      ...photoMakerPayload\n    } = payload;\n\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n    let taskUUIDs: string[] = [];\n    let retryCount = 0;\n\n    const startTime = Date.now();\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          retryCount++;\n          const imagesWithSimilarTask = this._globalImages.filter((img) =>\n            taskUUIDs.includes(img.taskUUID)\n          );\n\n          const taskUUID = customTaskUUID || getUUID();\n          taskUUIDs.push(taskUUID);\n\n          const imageRemaining = numberResults - imagesWithSimilarTask.length;\n\n          const payload = {\n            ...photoMakerPayload,\n            ...(photoMakerPayload.seed\n              ? { seed: photoMakerPayload.seed }\n              : { seed: getRandomSeed() }),\n            ...(moreOptions ?? {}),\n            taskUUID,\n            taskType: ETaskType.PHOTO_MAKER,\n            numberResults,\n          };\n\n          this.send({\n            ...payload,\n            numberResults: imageRemaining,\n          });\n\n          lis = this.listenToImages({\n            onPartialImages,\n            taskUUID: taskUUID,\n            groupKey: LISTEN_TO_IMAGES_KEY.REQUEST_IMAGES,\n            requestPayload: includePayload ? payload : undefined,\n            startTime: includeGenerationTime ? startTime : undefined,\n          });\n\n          const promise = await this.getSimilarImages({\n            taskUUID: taskUUIDs,\n            numberResults,\n            lis,\n          });\n\n          lis.destroy();\n\n          return promise as TPhotoMakerResponse[];\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      if ((e as any).taskUUID) {\n        throw e;\n      }\n      if (retryCount >= totalRetry) {\n        return this.handleIncompleteImages({\n          taskUUIDs,\n          error: e,\n        }) as TPhotoMakerResponse[];\n      }\n    }\n  };\n\n  modelSearch = async (\n    payload: TModelSearch\n  ): Promise<TModelSearchResponse> => {\n    return this.baseSingleRequest({\n      payload: {\n        ...payload,\n        taskType: ETaskType.MODEL_SEARCH,\n      },\n      debugKey: \"model-search\",\n    });\n  };\n\n  imageMasking = async (\n    payload: TImageMasking\n  ): Promise<TImageMaskingResponse> => {\n    return this.baseSingleRequest({\n      payload: {\n        ...payload,\n        taskType: ETaskType.IMAGE_MASKING,\n      },\n      debugKey: \"image-masking\",\n    });\n  };\n\n  imageUpload = async (\n    payload: TImageUpload\n  ): Promise<TImageUploadResponse> => {\n    return this.baseSingleRequest({\n      payload: {\n        ...payload,\n        taskType: ETaskType.IMAGE_UPLOAD,\n      },\n      debugKey: \"image-upload\",\n    });\n  };\n\n  protected baseSingleRequest = async <T>({\n    payload,\n    debugKey,\n    mockResponse,\n    isMultiple,\n  }: {\n    payload: Record<string, any>;\n    debugKey: string;\n    mockResponse?: any;\n    isMultiple?: boolean;\n  }): Promise<T> => {\n    const {\n      retry,\n      customTaskUUID,\n      includePayload,\n      includeGenerationTime,\n      ...restPayload\n    } = payload;\n\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    const startTime = Date.now();\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          const taskUUID = customTaskUUID || getUUID();\n          const payload = {\n            ...restPayload,\n            taskUUID,\n          };\n\n          // this.send(payload);\n\n          if (!mockResponse) {\n            this.send(payload);\n          } else {\n            // Simulate a delay and inject the mock response\n            setTimeout(() => {\n              this._globalMessages[taskUUID] = mockResponse;\n            }, 1000);\n          }\n\n          lis = this.globalListener({\n            taskUUID,\n          });\n\n          const response = await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              // console.log(\"multiple\", isMultiple);\n              const response = isMultiple\n                ? this.getMultipleMessages({ taskUUID })\n                : this.getSingleMessage({ taskUUID });\n              if (!response) return;\n\n              if (response?.error) {\n                reject(response);\n                return true;\n              }\n\n              if (response) {\n                delete this._globalMessages[taskUUID];\n                resolve(response);\n                return true;\n              }\n            },\n            {\n              debugKey,\n              timeoutDuration: this._timeoutDuration,\n            }\n          );\n\n          this.insertAdditionalResponse({\n            response: response,\n            payload: includePayload ? payload : undefined,\n            startTime: includeGenerationTime ? startTime : undefined,\n          });\n\n          lis.destroy();\n          return response as T;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  async ensureConnection() {\n    let isConnected = this.connected();\n    if (isConnected || this._url === BASE_RUNWARE_URLS.TEST) return;\n\n    const retryInterval = 2000;\n    const pollingInterval = 200;\n    // const pollingInterval = this._sdkType === SdkType.CLIENT ? 200 : 2000;\n\n    try {\n      if (this.isInvalidAPIKey()) {\n        throw this._connectionError;\n      }\n\n      return new Promise((resolve, reject) => {\n        //  const isConnected =\n        let retry = 0;\n        const MAX_RETRY = 30;\n\n        const localConnectionUUID = getUUID();\n\n        let retryIntervalId: any;\n        let pollingIntervalId: any;\n\n        const clearAllIntervals = () => {\n          this.ensureConnectionUUID = null;\n          clearInterval(retryIntervalId);\n          clearInterval(pollingIntervalId);\n        };\n\n        if (this._sdkType === SdkType.SERVER) {\n          retryIntervalId = setInterval(async () => {\n            try {\n              const hasConnected = this.connected();\n\n              // only one instance should be responsible for making the call again, not other ensureConnection\n              let shouldCallServer = false;\n\n              if (\n                !this.ensureConnectionUUID ||\n                localConnectionUUID === this.ensureConnectionUUID\n              ) {\n                if (!this.ensureConnectionUUID) {\n                  this.ensureConnectionUUID = localConnectionUUID;\n                }\n                shouldCallServer = true;\n              }\n\n              // Retry every (retryInterval % retry) => 60s\n              // every 20 seconds (ie. => retry is 10 (20s), retry is 20 (40s))\n              const SHOULD_RETRY = retry % 10 === 0 && shouldCallServer;\n\n              if (hasConnected) {\n                clearAllIntervals();\n                resolve(true);\n              } else if (retry >= MAX_RETRY) {\n                clearAllIntervals();\n                reject(new Error(\"Retry timed out\"));\n              } else {\n                if (SHOULD_RETRY) {\n                  this.connect();\n                }\n                retry++;\n              }\n            } catch (error) {\n              clearAllIntervals();\n              reject(error);\n            }\n          }, retryInterval);\n        }\n\n        pollingIntervalId = setInterval(async () => {\n          const hasConnected = this.connected();\n\n          if (hasConnected) {\n            clearAllIntervals();\n            resolve(true);\n            return;\n          }\n          if (!!this.isInvalidAPIKey()) {\n            clearAllIntervals();\n            reject(this._connectionError);\n            return;\n          }\n        }, pollingInterval);\n      });\n    } catch (e) {\n      this.ensureConnectionUUID = null;\n      this._connectionError = undefined;\n\n      throw (\n        this._connectionError ??\n        \"Could not connect to server. Ensure your API key is correct\"\n      );\n    }\n  }\n\n  private async getSimilarImages({\n    taskUUID,\n    numberResults,\n    shouldThrowError,\n    lis,\n  }: {\n    taskUUID: string | string[];\n    numberResults: number;\n    shouldThrowError?: boolean;\n    lis: any;\n  }): Promise<IImage[] | IError> {\n    return (await getIntervalWithPromise(\n      ({ resolve, reject, intervalId }) => {\n        const taskUUIDs = Array.isArray(taskUUID) ? taskUUID : [taskUUID];\n        const imagesWithSimilarTask = this._globalImages.filter((img) =>\n          taskUUIDs.includes(img.taskUUID)\n        );\n\n        if (this._globalError) {\n          const newData = this._globalError;\n          this._globalError = undefined;\n          // throw errorData[0]\n          clearInterval(intervalId);\n          reject<IError>?.(newData);\n          return true;\n        }\n        // onPartialImages?.(imagesWithSimilarTask)\n        else if (imagesWithSimilarTask.length >= numberResults) {\n          // lis?.destroy();\n          clearInterval(intervalId);\n          this._globalImages = this._globalImages.filter(\n            (img) => !taskUUIDs.includes(img.taskUUID)\n          );\n          resolve<IImage[]>([...imagesWithSimilarTask].slice(0, numberResults));\n          return true;\n          // Resolve the promise with the data\n        }\n      },\n      {\n        debugKey: \"getting images\",\n        shouldThrowError,\n        timeoutDuration: this._timeoutDuration,\n      }\n    )) as IImage[];\n  }\n\n  private getSingleMessage = ({ taskUUID }: { taskUUID: string }) => {\n    const value = this._globalMessages[taskUUID]?.[0];\n    const errorValue = this._globalMessages[taskUUID];\n    if (!value && !errorValue) return null;\n    return errorValue?.error ? errorValue : value;\n  };\n  private getMultipleMessages = ({ taskUUID }: { taskUUID: string }) => {\n    // console.log(\"global\", this._globalMessages);\n    const value = this._globalMessages[taskUUID]?.[0];\n    const mainValue = this._globalMessages[taskUUID];\n    if (!value && !mainValue) return null;\n    return mainValue;\n  };\n\n  private insertAdditionalResponse = <T>({\n    response,\n    payload,\n    startTime,\n  }: {\n    response: T;\n    payload?: Record<string, any>;\n    startTime?: number;\n  }) => {\n    if (!payload && !startTime) return;\n    const res = response as any;\n    res.additionalResponse = {};\n\n    if (!!payload) {\n      (response as any).additionalResponse.payload = payload;\n    }\n    if (!!startTime) {\n      (response as any).additionalResponse.generationTime =\n        Date.now() - startTime;\n    }\n  };\n\n  private handleIncompleteImages({\n    taskUUIDs,\n    error,\n  }: {\n    taskUUIDs: string[];\n    error: any;\n  }) {\n    const imagesWithSimilarTask = this._globalImages.filter((img) =>\n      taskUUIDs.includes(img.taskUUID)\n    );\n    if (imagesWithSimilarTask.length > 1) {\n      this._globalImages = this._globalImages.filter(\n        (img) => !taskUUIDs.includes(img.taskUUID)\n      );\n      return imagesWithSimilarTask;\n    } else {\n      throw error;\n    }\n  }\n\n  disconnect = async () => {\n    this._shouldReconnect = false;\n    this._ws?.terminate?.();\n    this._ws?.close?.();\n  };\n\n  private connected = () =>\n    this.isWebsocketReadyState() && !!this._connectionSessionUUID;\n  //end of data\n}\n","import { RunwareBase } from \"./Runware-base\";\nimport ReconnectingWebsocket from \"./reconnect\";\nimport { ReconnectingWebsocketProps, RunwareBaseType } from \"./types\";\n\nexport class RunwareClient extends RunwareBase {\n  constructor(props: RunwareBaseType) {\n    const { shouldReconnect, ...rest } = props;\n\n    super(rest);\n    this._ws = new (ReconnectingWebsocket as any)(\n      this._url\n    ) as ReconnectingWebsocketProps;\n    this.connect();\n  }\n}\n","// @ts-ignore\n// import ReconnectingWebsocket from \"./reconnect\";\nimport WebSocket from \"ws\";\n\nimport { RunwareBase } from \"./Runware-base\";\nimport { ETaskType, RunwareBaseType, SdkType } from \"./types\";\nimport { delay } from \"./utils\";\n\n// let allImages: IImage[] = [];\n\nexport class RunwareServer extends RunwareBase {\n  _instantiated: boolean = false;\n  _listeners: any[] = [];\n  _reconnectingIntervalId: null | any = null;\n  _pingTimeout: any;\n  _pongListener: any;\n\n  constructor(props: RunwareBaseType) {\n    super(props);\n\n    this._sdkType = SdkType.SERVER;\n    this.connect();\n  }\n\n  // protected addListener({\n  //   lis,\n  //   check,\n  //   groupKey,\n  // }: {\n  //   lis: (v: any) => any;\n  //   check: (v: any) => any;\n  //   groupKey?: string;\n  // }) {\n  //   const listener = (msg: any) => {\n  //     if (msg?.error) {\n  //       lis(msg);\n  //     } else if (check(msg)) {\n  //       lis(msg);\n  //     }\n  //   };\n  //   const groupListener = { key: getUUID(), listener, groupKey };\n  //   this._listeners.push(groupListener);\n  //   const destroy = () => {\n  //     this._listeners = removeListener(this._listeners, groupListener);\n  //   };\n\n  //   return {\n  //     destroy,\n  //   };\n  // }\n\n  protected async connect() {\n    if (!this._url) return;\n\n    this.resetConnection();\n\n    this._ws = new WebSocket(this._url, {\n      perMessageDeflate: false,\n    });\n\n    // delay(1);\n\n    this._ws.on(\"error\", () => {});\n    this._ws.on(\"close\", () => {\n      this.handleClose();\n    });\n\n    this._ws.on(\"open\", () => {\n      if (this._reconnectingIntervalId) {\n        clearInterval(this._reconnectingIntervalId);\n      }\n      if (this._connectionSessionUUID && this.isWebsocketReadyState()) {\n        this.send({\n          taskType: ETaskType.AUTHENTICATION,\n          apiKey: this._apiKey,\n          connectionSessionUUID: this._connectionSessionUUID,\n        });\n      } else {\n        if (this.isWebsocketReadyState()) {\n          this.send({\n            apiKey: this._apiKey,\n            taskType: ETaskType.AUTHENTICATION,\n          });\n        }\n      }\n\n      this.addListener({\n        taskUUID: ETaskType.AUTHENTICATION,\n        lis: (m) => {\n          if (m?.error) {\n            this._connectionError = m;\n            return;\n          }\n          this._connectionSessionUUID =\n            m?.[ETaskType.AUTHENTICATION]?.[0]?.connectionSessionUUID;\n          this._connectionError = undefined;\n        },\n      });\n    });\n\n    this._ws.on(\"message\", (e: any, isBinary: any) => {\n      const data = isBinary ? e : e?.toString();\n      if (!data) return;\n      const m = JSON.parse(data);\n\n      // console.log(\"response\", JSON.stringify(m, null, 4));\n\n      this._listeners.forEach((lis) => {\n        const result = lis.listener(m);\n        if (result) {\n          return;\n        }\n      });\n    });\n  }\n\n  protected send = (msg: Object) => {\n    this._ws.send(JSON.stringify([msg]));\n  };\n\n  protected handleClose() {\n    if (this.isInvalidAPIKey()) {\n      return;\n    }\n    if (this._reconnectingIntervalId) {\n      clearInterval(this._reconnectingIntervalId);\n    }\n\n    if (this._shouldReconnect) {\n      setTimeout(() => this.connect(), 1000);\n    }\n    // this._reconnectingIntervalId = setInterval(() => this.connect(), 1000);\n  }\n\n  protected resetConnection = () => {\n    if (this._ws) {\n      this._listeners.forEach((list) => {\n        list?.destroy?.();\n      });\n      this._ws.removeAllListeners(); // Remove all listeners\n      if (this._ws.readyState === 1) {\n        this._ws.terminate();\n        this._ws.close(); // Attempt to close gracefully\n      }\n\n      this._ws = null;\n      this._listeners = [];\n    }\n  };\n\n  protected heartBeat() {\n    clearTimeout(this._pingTimeout);\n\n    this._pingTimeout = setTimeout(() => {\n      if (this.isWebsocketReadyState()) {\n        this.send({ ping: true });\n      }\n    }, 5000);\n  }\n\n  //end of data\n}\n","// @ts-ignore\nimport { RunwareClient } from \"./Runware-client\";\nimport { RunwareServer } from \"./Runware-server\";\n\nlet Runware: typeof RunwareClient | typeof RunwareServer;\n\nif (typeof window === \"undefined\") {\n  Runware = RunwareServer;\n} else {\n  Runware = RunwareClient;\n}\n\nexport { Runware };\n"],"mappings":"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","names":["require_reconnect","__commonJSMin","exports","module","isWebSocket","constructor","isGlobalWebSocket","getDefaultOptions","bypassProperty","src","dst","name","value","initReconnectionDelay","config","updateReconnectionDelay","previousDelay","newDelay","LEVEL_0_EVENTS","reassignEventListeners","ws","oldWs","listeners","type","listener","options","ReconnectingWebsocket","url","protocols","connectingTimeout","reconnectDelay","retriesCount","shouldRetry","key","log","params","emitError","code","msg","err","fn","handleClose","connect","reason","keepClosed","fastClose","delay","fakeCloseEvent","data","l","Environment","SdkType","ETaskType","EControlMode","EPreProcessorGroup","EPreProcessor","EOpenPosePreProcessor","EModelFormat","EModelArchitecture","EModelType","EModelConditioning","EPhotoMakerEnum","uuidv4","validateUUID","TIMEOUT_DURATION","MINIMUM_TIMEOUT_DURATION","POLLING_INTERVAL","BASE_RUNWARE_URLS","removeFromAray","col","targetElem","i","getIntervalWithPromise","callback","debugKey","timeoutDuration","shouldThrowError","pollingInterval","resolve","reject","timeoutId","intervalId","fileToBase64","file","reader","getUUID","isValidUUID","uuid","accessDeepObject","key","data","useZero","shouldReturnString","acc","curr","returnZero","currentValue","index","delay","time","milliseconds","resolve","removeListener","listeners","listener","lis","evaluateNonTrue","key","value","getRandomNumber","min","max","getRandomSeed","getIntervalAsyncWithPromise","callback","debugKey","timeoutDuration","TIMEOUT_DURATION","shouldThrowError","pollingInterval","POLLING_INTERVAL","MINIMUM_TIMEOUT_DURATION","resolve","reject","timeoutId","intervalId","error","asyncRetry","apiCall","options","delayInSeconds","callback","maxRetries","error","delay","RunwareBase","apiKey","url","BASE_RUNWARE_URLS","shouldReconnect","globalMaxRetries","timeoutDuration","TIMEOUT_DURATION","msg","file","asyncRetry","taskUUID","getUUID","isValidUUID","imageBase64","fileToBase64","inputImage","preProcessorType","height","width","outputType","outputFormat","highThresholdCanny","lowThresholdCanny","includeHandsAndFaceOpenPose","includeCost","outputQuality","customTaskUUID","retry","includeGenerationTime","includePayload","totalRetry","lis","startTime","image","payload","evaluateNonTrue","guideImage","getIntervalWithPromise","resolve","reject","uploadedImage","e","imageUploaded","response","newReverseClip","skipResponse","rest","request","numberResults","allVideos","getIntervalAsyncWithPromise","videos","video","err","upscaleFactor","newUpscaleGan","prompt","promptMaxLength","promptVersions","reducedPrompt","onUploadStream","addModelPayload","result","errorResult","error","moreOptions","onPartialImages","photoMakerPayload","taskUUIDs","retryCount","imagesWithSimilarTask","img","imageRemaining","getRandomSeed","promise","debugKey","mockResponse","isMultiple","restPayload","value","errorValue","mainValue","res","props","instance","groupKey","listener","arrayMessage","arrayErrors","filteredMessage","v","groupListener","removeListener","m","data","removeFromAray","requestPayload","images","accessDeepObject","uploadEndpoint","checkNSFW","positivePrompt","negativePrompt","seedImage","maskImage","strength","model","steps","scheduler","seed","CFGScale","clipSkip","usePromptWeighting","promptWeighting","refiner","maskMargin","controlNet","lora","embeddings","ipAdapters","outpaint","acceleratorOptions","advancedFeatures","referenceImages","requestObject","seedImageUUID","maskImageUUID","controlNetData","uploadedMaskInitiator","i","controlData","endStep","startStep","weight","controlMode","startStepPercentage","endStepPercentage","controlNetModel","newRequestObject","retryInterval","pollingInterval","MAX_RETRY","localConnectionUUID","retryIntervalId","pollingIntervalId","clearAllIntervals","hasConnected","shouldCallServer","SHOULD_RETRY","shouldThrowError","intervalId","newData","import_reconnect","RunwareClient","RunwareBase","props","shouldReconnect","rest","ReconnectingWebsocket","WebSocket","RunwareServer","RunwareBase","props","msg","list","WebSocket","m","isBinary","data","lis","Runware","RunwareServer","RunwareClient"]}